(function(){"use strict";class c{constructor(){this.isInitialized=!1,this.initializeCanvas()}initializeCanvas(){try{this.canvas=new OffscreenCanvas(1024,1024);const e=this.canvas.getContext("2d");if(!e)throw new Error("Failed to get 2D context");this.ctx=e,this.isInitialized=!0}catch(e){console.error("Failed to initialize OffscreenCanvas:",e),this.isInitialized=!1}}async processTask(e){const t=performance.now();try{if(!this.isInitialized)throw new Error("Worker not initialized");let a;switch(e.type){case"batch_process":a=await this.processBatch(e.data,e.options);break;case"single_process":a=await this.processSingle(e.data,e.options);break;case"resize":a=await this.resizeImage(e.data,e.options);break;case"blend":a=await this.blendImages(e.data,e.options);break;default:throw new Error(`Unknown task type: ${e.type}`)}const i=performance.now()-t;return{id:e.id,success:!0,data:a,processingTime:i}}catch(a){const i=performance.now()-t;return{id:e.id,success:!1,error:a instanceof Error?a.message:"Unknown error",processingTime:i}}}async processBatch(e,t){const a=[];for(const i of e){const r=await this.processSingle(i,t);a.push(r)}return a}async processSingle(e,t){const a=new Blob([e]);let i=await createImageBitmap(a);return(t?.width||t?.height)&&(i=await this.resizeImageBitmap(i,t.width||i.width,t.height||i.height)),i}async resizeImage(e,t){const a=new Blob([e]),i=await createImageBitmap(a),r=t?.width||i.width,s=t?.height||i.height,h=await this.resizeImageBitmap(i,r,s);return i.close(),h}async resizeImageBitmap(e,t,a){return this.canvas.width=t,this.canvas.height=a,this.ctx.clearRect(0,0,t,a),this.ctx.drawImage(e,0,0,t,a),await createImageBitmap(this.canvas)}async blendImages(e,t){if(e.length<2)throw new Error("Blend operation requires at least 2 images");const a=await Promise.all(e.map(s=>createImageBitmap(new Blob([s])))),i=a[0];this.canvas.width=i.width,this.canvas.height=i.height,this.ctx.clearRect(0,0,i.width,i.height),this.ctx.drawImage(i,0,0);const r=t?.blendMode||"source-over";this.ctx.globalCompositeOperation=r,t?.opacity!==void 0&&(this.ctx.globalAlpha=t.opacity);for(let s=1;s<a.length;s++)this.ctx.drawImage(a[s],0,0);return this.ctx.globalCompositeOperation="source-over",this.ctx.globalAlpha=1,a.forEach(s=>s.close()),await createImageBitmap(this.canvas)}}const o=new c;self.onmessage=async n=>{const e=n.data,t=await o.processTask(e);self.postMessage(t,{transfer:t.data?Array.isArray(t.data)?t.data:[t.data]:[]})}})();
